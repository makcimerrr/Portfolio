---
title: Filler
description: ü¶Ä Implementation of the Filler game in Rust
date: 2024-11-16
image: /filler.png?height=auto&width=auto
tags: ["Rust", "Algorithm", "Game"]
github: https://github.com/makcimerrr/filler
featured: true
---

# üß© Filler Game - Impl√©mentation en Rust ü¶Ä
## üéÆ Le Jeu : Qu'est-ce que Filler ?
Filler est un jeu strat√©gique algorithmique o√π deux robots s'affrontent sur une grille appel√©e "Anfield", visant √† conqu√©rir le plus de territoire possible en utilisant des pi√®ces al√©atoires fournies par un moteur de jeu.

### üèÜ Objectif
Les joueurs placent des pi√®ces al√©atoires √† tour de r√¥le, chaque pi√®ce devant **chevaucher d'une cellule** avec leur territoire pr√©c√©dent. Le joueur qui capture le plus de territoire gagne ! Si un joueur ne peut pas placer une pi√®ce, il doit s'arr√™ter, tandis que l'autre joueur continue jusqu'√† ce qu'il ne puisse plus placer de pi√®ces non plus.

### üèüÔ∏è L'Anfield (Grille)
L'Anfield est une grille de lignes et de colonnes configurables. Chaque joueur commence √† une position unique (*@* pour le Joueur 1 et *$* pour le Joueur 2) et doit √©tendre son territoire de mani√®re strat√©gique. Voici un exemple de grille de d√©part (30 x 14) :

```plaintext
..............................
..............................
..$...........................
..............................
..............................
..............................
..............................
..............................
..............................
..............................
...........................@..
..............................
..............................
```

### üß© Pi√®ces
√Ä chaque tour, le moteur de jeu fournit une nouvelle pi√®ce de taille et forme al√©atoires. Voici quelques exemples :

- **Pi√®ce 2x2** :
```plaintext
.#
#.
```

- **Pi√®ce 5x4** :
```plaintext
.##..
.##..
..#..
...#.
```

- **Pi√®ce 6x3** :
```plaintext
.##...
###...
#..#..
```

### ü§ñ Robots
Deux robots s'affrontent pour le territoire, et chaque tour, une nouvelle pi√®ce est plac√©e sur la grille. Les joueurs marquent des points √† chaque placement r√©ussi.

Le jeu se termine lorsqu'aucun joueur ne peut plus placer de pi√®ce ou si l'un d'eux rencontre une erreur comme un d√©passement de temps. Le gagnant est celui qui a captur√© le plus de territoire !

## ü¶Ä Impl√©mentation en Rust - Structure du Programme

Cette solution Filler en Rust inclut des modules organis√©s pour un code propre et maintenable :

### üìÇ Structure des Fichiers

- **main.rs`** : Point d'entr√©e qui initialise et g√®re la boucle du jeu.
- **input.rs** : Analyse les entr√©es provenant du moteur de jeu.
- **player.rs** : Contient la structure **Player** et g√®re les op√©rations des joueurs.
- **grid.rs** : G√®re l'√©tat de la grille et v√©rifie les placements valides.
- **piece.rs** : G√®re les donn√©es des pi√®ces du moteur de jeu et la logique de placement des pi√®ces sur la grille.
- **distance.rs** : Calcule les distances entre les pi√®ces et le territoire de l'adversaire.
- **score.rs** : √âvalue et attribue des scores aux placements potentiels.

### üîç Aper√ßu de la Logique
1. **Initialisation** : **main.rs** configure les joueurs et la grille, lan√ßant ainsi le jeu.
2. **Analyse des Entr√©es** : **input.rs** traite le num√©ro du joueur, la grille, et les pi√®ces.
3. **Gestion de la Grille** : **grid.rs** suit l'√©tat de la grille et valide les coups.
4. **Placement des Pi√®ces** : **piece.rs** trouve les placements valides et fournit les coordonn√©es, en g√©rant aussi la recherche du meilleur emplacement pour les pi√®ces.
5. **Calcul des Distances** : **distance.rs** calcule les distances entre les pi√®ces et les coordonn√©es ennemies.
6. **√âvaluation des Scores** : **score.rs** √©value les placements en fonction de plusieurs crit√®res heuristiques.

### üß† Aper√ßu de la Logique du Bot

La logique du bot repose sur une strat√©gie de maximisation du territoire tout en minimisant les risques li√©s √† l'adversaire. Voici un r√©sum√© simplifi√© :

1. **Analyse des Pi√®ces** : √Ä chaque tour, le bot commence par analyser la pi√®ce fournie par le moteur de jeu. Il v√©rifie les dimensions, la forme, et les points de chevauchement viables, dans le but de positionner la pi√®ce de mani√®re √† √©tendre efficacement son territoire contr√¥l√©.

2. **Recherche de Placement Valide** : Le bot calcule tous les placements possibles sur la grille. Il s'assure que le placement :
 - Chevauche exactement une fois son propre territoire.
 - √âvite tout chevauchement avec le territoire de l'adversaire.

3. **√âvaluation et S√©lection** : Chaque placement valide est √©valu√© √† l'aide d'un syst√®me de notation de base qui privil√©gie :
 - L'extension du territoire du bot vers les zones non revendiqu√©es.
 - L'√©vitement des coups trop proches du territoire de l'adversaire, r√©duisant ainsi les risques de blocage.

4. **Ex√©cution du Mouvement Optimal** : Une fois le meilleur placement identifi√©, le bot renvoie les coordonn√©es au moteur de jeu, finalisant ainsi le coup.

5. **Strat√©gie Adaptative** : Si aucun placement valide n'est trouv√©, le bot sort gracieusement. Le bot s'adapte en fonction de l'espace libre restant, ajustant dynamiquement sa strat√©gie entre expansion offensive et positionnement d√©fensif en fonction de l'√©tat du jeu.

Cette approche garantit une capture efficace du territoire tout en minimisant les risques li√©s aux coups de l'adversaire, aboutissant √† un style de jeu flexible et strat√©gique.

## üõ†Ô∏è Installation et Utilisation sur Linux & macOS

### üê≥ Configuration de Docker
T√©l√©chargez les fichiers de l'image Docker ici : [T√©l√©charger l'image Docker](https://assets.01-edu.org/filler/filler.zip)

1. **Construire l'Image Docker** :
 - D√©compressez le dossier **docker_image** et naviguez √† l'int√©rieur :
```bash
docker build -t filler .
```

2. **Lancer le Conteneur Docker** :
 - Montez le r√©pertoire de la solution dans Docker :
```bash
docker run -v "$(pwd)/solution":/filler/solution -it filler
```
 - Le dossier **solution** sur la machine h√¥te est mont√©, vous permettant d'√©diter les fichiers avec votre √©diteur pr√©f√©r√© en dehors de Docker et de tester dans Docker.

### üöÄ Compiler et Ex√©cuter
Dans le terminal Docker :

1. **Compiler la Solution** :
```bash
cd solution
cargo build --release
```

2. **Lancer le Jeu** :
```bash
./game_engine -f maps/map01 -p1 robots/bender -p2 solution/target/release/solution
```

### üìñ Contr√¥les du Jeu
- √Ä chaque tour, le moteur de jeu fournit une grille et une pi√®ce. Affichez les coordonn√©es dans le format :
```plaintext
X Y\n
```
Par exemple :
```plaintext
7 2\n
```

- Si aucun placement valide n'est possible, affichez **0 0\n**.

### üí° Exemple de Partie
Pour lancer une partie entre **bender** et **terminator** sur **map01**, utilisez :
```bash
./game_engine -f maps/map01 -p1 robots/bender -p2 robots/terminator
```

### üîß Flags du Moteur de Jeu
Voici des flags suppl√©mentaires pour personnaliser le gameplay :
- **-f, -file** : Chemin vers le fichier de carte.
- **-p1, -player1** : Chemin vers l'ex√©cutable du Joueur 1.
- **-p2, -player2** : Chemin vers l'ex√©cutable du Joueur 2.
- **-q, -quiet** : Mode silencieux.
- **-r, -refresh** : Ajuster le taux de rafra√Æchissement.
- **-s, -seed** : Utiliser une graine sp√©cifique pour la reproductibilit√©.
- **-t, -time** : D√©finir un d√©lai d'attente (par d√©faut 10 secondes).

Avec cette configuration, vous √™tes pr√™t √† d√©velopper, tester et conqu√©rir dans Filler ! Bonne chance, et que la meilleure strat√©gie gagne ! üéâ